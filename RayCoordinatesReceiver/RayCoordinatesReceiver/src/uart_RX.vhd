-------------------------------------------------------------------------------
--
-- Title       : rs_in
-- Design      : rs_in
-- Author      : 
-- Company     : 
--
-------------------------------------------------------------------------------
--
-- Description : 
--
-------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_unsigned.all;--!!!!!!!!!!!!!!!!!! обрати внимание на эту строчку! она нужна для операций типа   cnt<= cnt+ '1';

entity rs_in is	  
	port(
	clk			: in std_logic;  --100Mhz
	reset		: in std_logic;  -- 1 - reset
	uart_in		: in std_logic;
	data_out	: out std_logic_vector(7 downto 0);
	data_rdy	: out std_logic
	);
end rs_in;			



architecture rs_in of rs_in is 
constant half_start_bit	: std_logic_vector(15 downto 0):=x"01B2"; -- это как пример. точное значение нужно подобрать в зависимости от соотношение частот UART и clk.
constant length_bit	: std_logic_vector(15 downto 0):=x"0361"; -- это как пример. точное значение нужно подобрать в зависимости от соотношение частот UART и clk.
constant uart_length	: std_logic_vector(3 downto 0):=x"7"; -- длина посылки UART в битах
-- если допустим это значние окажется, скажем x"2F6", то иметь 16 разрядов для данного значения является лишним. 
-- достаточно будет только 10 бит 
signal cnt0			: std_logic_vector(15 downto 0); -- счетчик отсчета стартового бита  
signal cnt1			: std_logic_vector(15 downto 0); --счетчик контроля переходов между битами 
signal cnt_bits		: std_logic_vector(7 downto 0);  --счетчик принимаемых бит

signal st_main		: std_logic_vector(1 downto 0):="00";		--сигнал, определяющий работу конечного автомата. будет не более 4 сосотяний
signal shift_reg	: std_logic_vector(7 downto 0);

-- функция реверса регистра
function reverse(X : in std_logic_vector) return std_logic_vector is
variable ret : std_logic_vector(X'range);
begin
    for i in X'range loop
        ret(i) := X(X'left - i);
    end loop;
   return ret;
end function;

begin
	
pr_main: process(clk)
	
begin  
	if(rising_edge(clk))then --все находится внутри данного if, чтоб было синхронным
		if(reset = '1')then  -- определяем состояние внешних и внутренних сигналов по сбросу
			st_main	<= "00";  --сигнал, определяющий работу конечного автомата. будет не более 4 сосотяний
			data_rdy	<= '0';	-- всегда требуется сигнал готвоности выходных данных по ресету обнулять. иначе могут работать некорректно последующие схемы. которые используют этот сигнал  
			cnt0	<= (others=>'0');	 
			data_out	<= (others=>'0');
		else   
			case st_main is 
			when "00"=>	  --начальное состояние. ждем стартовый бит
				if(	uart_in = '0')then --если пришел стартовый бит, начинаем считать половину длины этого стартового бита, чтоб оказаться максимально близко к середине
					-- если этого не сделать, то в силу асинхронности интерфейса можно в конце посылки переползти из одного бита в другой и 
					-- неверно декодировать последние биты. Особенно это актуально на больших скоростях UART
					cnt0<= cnt0+ '1';  
				else
					cnt0	<= (others=>'0'); --если был ложный uart_in = 0, то мы при переходе uart_in в 1 сбросим счетчик. ложное срабатывание может возникнуть из-за асинхронности  передающего устройства
					--и нас. допустим, передатчик начал передавать, а мы только сняли ресет. Данная защита полоноценной не является.																		 		
				end if;
				if( cnt0 = half_start_bit)then --если мы досчитали до данного значения, то оказались посередине стартового бита 
					st_main	<= "01";	 --переходим в состояние определения середины каждого последующего бита
					--cnt0 <=(others=>'0'); -- сброс счетчика отсчета стартового бита
				end if;	 
				cnt1		<= (others=> '0'); --сброс счетчика для контроля переходов между битами
				cnt_bits	<= (others=> '0'); --сброс счетчика посылки
				--shift_reg  	<= (others=> '0'); --сброс сдвигового регистра
				data_rdy	<= '0';					
			when "01"=>	--определение середины каждого последующего бита
				if( cnt1 = length_bit)then --если мы досчитали до данного значения, то переместились из одного бита в другой 
					st_main	<= "10";	 --переходим в состояние декодирования посылки uart
				end if;	
				cnt1<= cnt1+ '1';  
				cnt0 <=(others=>'0'); -- сброс счетчика отсчета стартового бита
			when "10"=>	--декодирование посылки uart
				if(cnt_bits = uart_length)then 	  
					st_main	<= "11";-- если приняли все 8 бит, то переходим в последнее сосотяние, в котором взводим сигнал готовности		
				else   
					st_main	<= "01";-- все 8 бит еще не приняли, идем принимать следующий бит
				end if;
				cnt1		<= (others=> '0'); --сброс счетчика для контроля переходов между битами
				shift_reg	<= shift_reg(6 downto 0) & uart_in; -- операция сдвига влево. постепенно заполняем регистр принятыми битами	 
				cnt_bits <= cnt_bits + '1'; -- очередной бит считан, значит увеличиваем счетчик принятых бит
			when "11"=>	  -- послыка принята вся, формируем выходныфе сигналы модуля
				if(uart_in = '1')then  -- если на вход пришел стоповый бит, то переходим в начальное состояние для поиска следующего стартового бита	
					st_main		<= "00"; -- 	
					data_rdy	<= '1';	
				else
					--какие то действия, если стоп бита на входе нет.
				end if;
				data_out	<= reverse(shift_reg);--реверс последовательности бит для перевода MSB  в LSB
				--data_out	<= shift_reg;
				--data_rdy	<= '1';			
			
			when others=> null;
			end case;
		end if;
		
				  
		
	end if;
	
end process;



end rs_in;
